#!/bin/bash
# Purpose: *.patchtt functionality for ngcpcfg config/templates
################################################################################

set -e
set -u

# support testsuite
FUNCTIONS="${FUNCTIONS:-/usr/share/ngcp-ngcpcfg/functions/}"
HELPER="${HELPER:-/usr/share/ngcp-ngcpcfg/helper/}"
SCRIPTS="${SCRIPTS:-/usr/share/ngcp-ngcpcfg/scripts/}"

if ! [ -r "${FUNCTIONS}"/main ] ; then
  printf "Error: %s/main could not be read. Exiting.\n" "${FUNCTIONS}" >&2
  exit 1
fi

. "${FUNCTIONS}"/main

cd "${NGCPCTL_MAIN}"

## functions {{{
patch_help() {
  export TIME_FORMAT=''
  log_info "'ngcpcfg patch' walks thorugh all templates search for *.patchtt files"
  log_info "and generate *.customtt files based on the original template"
  log_info ""
  log_info "Sample:"
  log_info "  ngcpcfg patch [--help] [--force]"
  log_info ""
  log_info "Run 'man ngcpcfg' for more information."
}

request_confirmation() {
  if "${force:-false}" ; then
    log_info "Forcing action due to option '--force'"
    return 0
  fi

  log_info_n "Please confirm 'yes' or 'no': "

  # clearing STDIN
  while read -r -t 0; do read -r; done

  while true ; do
    read -r a
    case "${a,,}" in
      yes) return 0 ;;
      no) return 1 ;;
      *) log_info_n "Please answer 'yes' or 'no': " ;;
    esac
    unset a
  done
}

patch_search() {
  log_debug "Patch: searching for patchtt files availability"

  local patchlist
  patchlist=$(mktemp)

  local a=".sp[1,2]?"
  local b=".(web|db|prx|lb|slb)[0-9]+[a,b]?"
  local awk_regexp=".*patchtt.tt2(${a}|${b})?$"

  for dir in ${CONFIG_POOL} ; do
    [ -n "${dir}" ] || echo "${dir} doesn't exist" >&2
    # iterate over all files
    while read -r patch ; do
      # *NO* arguments provided via cmdline
      if [ -z "${1:-}" ] ; then
        echo "${patch}" >> "${patchlist}"
      else
        # arguments (file list/pattern) provided via cmdline
        for arg in "$@"; do
          if echo "${patch}" | grep -q -- "${arg}" ; then
            echo "${patch}" >> "${patchlist}"
          fi
        done
      fi
    done < <(find "${TEMPLATE_POOL_BASE}/${dir}" -regextype awk -iregex "${awk_regexp}")
  done

  # output patch list, make sure we provide the file names just once
  sort -u "${patchlist}"

  if [ -n "${DEBUG:-}" ] ; then
    # send to stderr since stdout is used from outside
    log_debug "Not removing temporary patchlist files since we are in debug mode:" >&2
    log_debug "  patchlist = ${patchlist}" >&2
  else
    rm -f "${patchlist}"
  fi
}

patch_validate() {
  local patch="$1"
  log_debug "Validating patch: '${patch}'"

  if [ ! -f "${patch}" ] ; then
    log_error "Missing patch file '${patch}'"
    RC=1
  fi

  local template="${patch%%.patchtt*}.tt2"

  if [ ! -f "${template}" ] ; then
    log_error "Missing template for patch '${patch}'"
    RC=1
  else
    log_debug "Found template for the patch: '${template}'"
  fi

  local customtt="${patch//.patchtt/.customtt}"
  if [ -f "${customtt}" ] ; then
    log_info "Overwritting customtt '${customtt}'"
  else
    log_debug "Not found customtt for the patch: '${customtt}'"
  fi
}

patch_apply() {
  local patch="$1"
  local template="${patch%%.patchtt*}.tt2"
  local customtt="${patch//.patchtt/.customtt}"

  if [ -f "${customtt}" ] ; then
    log_debug "Copying '${customtt}' to '${customtt}.oldpatched'"
    mv "${customtt}" "${customtt}.oldpatched"
  fi

  log_debug "Copying template '${template}' to '${customtt}' for patching"
  cp -a "${template}" "${customtt}"

  log_debug "Patching template/customtt '${customtt}' with '${patch}'"
  if patch "${customtt}" < "${patch}" ; then
    log_info "Succesfully created '${customtt}'"
  else
    log_error "Failed to apply patch '${patch}', see"
    RC=1
  fi

  log_debug "Deleting tmp file '${customtt}.oldpatched'"
  rm -f "${customtt}.oldpatched"
}

patch_main() {
  for patch in $(patch_search "$@") ; do
    log_info "Validating patch '${patch}'"
    patch_validate "${patch}"
  done

  if [ "${RC}" != "0" ] ; then
    log_error "Aborted here due to failed patch validation above"
    exit "${RC}"
  fi

  for patch in $(patch_search "$@") ; do
    log_info "Applying patch '${patch}'"
    patch_apply "${patch}"
  done

  if [ "${RC}" != "0" ] ; then
    log_error "Aborted here due to failed patching above"
    exit "${RC}"
  fi
}
## }}}

RC=0
force=false
help=false

clean_options="force,help"
_opt_temp=$(getopt --name "$0" -o +h --long ${clean_options} -- "$@")
if [ $? -ne 0 ]; then
  log_error "Try 'ngcpcfg patch --help' for more information."
  exit 1
fi
eval set -- "${_opt_temp}"

while : ; do
  case "$1" in
    --force) force=true ;;
    --help)  help=true  ;;
    --) shift ; break ;;
    *) log_error "Unknown option '$1'" ; exit 1 ;;
  esac
  shift
done

if ${help} ; then
  patch_help
  exit 0
fi

patch_main "$@"

if [ "${RC}" = "0" ] ; then
  log_info "Patch operation has finished successfuly."
else
  log_error "Some operations finished with an error, see details above."
fi

exit "${RC}"

## END OF FILE #################################################################
