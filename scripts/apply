#!/bin/bash
# Purpose: shortcut for build, services, commit in one run
################################################################################

set -e
set -u
set -o pipefail

# support testsuite
FUNCTIONS="${FUNCTIONS:-/usr/share/ngcp-ngcpcfg/functions/}"
HELPER="${HELPER:-/usr/share/ngcp-ngcpcfg/helper/}"
SCRIPTS="${SCRIPTS:-/usr/share/ngcp-ngcpcfg/scripts/}"

if ! [ -r "${FUNCTIONS}"/main ] ; then
  printf "Error: %s/main could not be read. Exiting.\n" "${FUNCTIONS}">&2
  exit 1
fi

. "${FUNCTIONS}"/main

# based on check_local_state() from scripts/status
check_for_outstanding_commits()  {
  log_debug "cd $NGCPCTL_MAIN"
  cd "$NGCPCTL_MAIN"

  log_debug "git status | grep -qE 'working (directory|tree) clean'"
  if git status | grep -qE 'working (directory|tree) clean' ; then
    return 1 # nothing to commit
  else
    return 0 # outstanding commits
  fi
}

if check_for_outstanding_commits && [ -z "${1:-}" ] ; then
  log_error "Uncommitted configuration files found."
  log_info  "Please provide commit message, like: $PN apply 'summary of your changes'"
  exit 1
fi

# ensure that we strip of the "--dry-services-run" option from the
# command line, so it doesn't end up in the commit action as commit message
SERVICE_OPTION=
orig_opts=("$*")
new_opts=

for i in ${orig_opts[*]} ; do
  case "$i" in
    --dry-services-run)
      SERVICE_OPTION="--dry-run"
      ;;
    *)
      new_opts+=($i)
      ;;
  esac
done

"${SCRIPTS}"/build
"${SCRIPTS}"/services ${SERVICE_OPTION:-}
"${SCRIPTS}"/commit "${new_opts[*]}"

# We "commit" AFTER we "build", therefore the state information is out of date
# and would be marked as "dirty". As we have full control over this during the
# "apply" run let's ensure it's not marked as dirty.
record_commit_id

## END OF FILE #################################################################
