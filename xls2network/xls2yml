#!/usr/bin/env python3

"""
Generate network.yml files from Excel sheets
============================================

This script takes an Excel file (parsed by openpyxl)
and generates the corresponding ``network.yml`` with
the data contained in the Excel sheets.
"""

import re
import logging
import argparse
import itertools

# input formatting
import openpyxl

# output formatting
import yaml

DESCRIPTION = 'Generate YAML network configuration from Excel sheets'


def unique_ids_generator():
    """A generator for unique IDs.
    A unique ID is an integer returned as string data type.
    This is used for dbnode, for example.
    """
    for i in itertools.count(1):
        yield str(i)

GLOBAL_UID_GEN = unique_ids_generator()


class VirtualLAN:
    """
    Mutable abstraction of a virtual LAN network.
    It stores data about the network such as an ID and
    a reference to the gateway.
    """

    def __init__(self, name, _id):
        self.name = name
        self.id = _id
        self.gateway = None

    def __str__(self):
        return 'vlan{}'.format(self.id)


class NetworkConnection:
    """
    Mutable abstraction of a network connection.
    It stores data about the connection such as the IP address in use.
    It potentially normalizes and validates settings when they are set.
    """

    def __init__(self, ip_addr, subnetmask, vlan, phy):
        self.ip_addr = ip_addr
        self.subnetmask = subnetmask
        self.vlan = vlan
        self.phy = phy

    @property
    def subnetmask(self):
        return self._subnetmask

    @subnetmask.setter
    def subnetmask(self, snm):
        snms = str(snm)
        # regular expression to match subnet masks such as '255.255.255.240'
        m = re.match(r'(\d{1,3})\.' * 3 + '(\d{1,3})$', snms)
        if m:
            self._subnetmask = snms
        else:
            errmsg = "Subnet mask '{}' has invalid format"
            parts = []
            while snms:
                e = min(len(snms), 3)
                try:
                    int(snms[0:e])
                except ValueError:
                    raise ValueError(errmsg.format(snm))
                parts.append(snms[0:e])
                snms = snms[e:]
            if len(parts) != 4:
                raise ValueError(errmsg.format(snm))
            self._subnetmask = '.'.join(parts)

    @property
    def network_type(self):
        # TODO: verify whether phy signifies 'lo'
        if self.phy == 'lo':
            return ['ssh_ext', 'api_int']
        return []


class Host:
    """
    Mutable abstraction of a host in a network.
    It stores the hostname and networks, the host is attached to.
    """

    def __init__(self, hostname):
        self.hostname = hostname
        self.nets = []

        assert bool(self.hostname), 'Hostname must not be empty'

    def add_net(self, net):
        """Attach a network connection to this host

        :param net:    the network to attach
        :type net:     NetworkConnection
        """
        self.nets.append(net)

    @property
    def peer(self):
        m = re.match(r'(\w{1,5}\d{1,2})([ab])$', self.hostname)
        if m:
            return m.group(1) + (m.group(2) == 'a' and 'b' or 'a')
        msg = "Unknown peer, cannot derive it from its hostname '{}'"
        raise ValueError(msg.format(self.hostname))

    @property
    def roles(self):
        rs = []
        if self.hostname.startswith('db'):
            rs.append('db')
        return rs

    def __str__(self):
        return self.hostname

    def yaml(self):
        """Returns the python data structure representing this host.
        The python data structure can be easily passed to the `pyaml`
        module to represent this host in YAML.
        """
        struct = {
            'lo': {
              'advertised_ip': [],
              'hwaddr': '00:00:00:00:00:00',
              'ip': '127.0.0.1',
              'netmask': '255.0.0.0',
              'shared_ip': [],
              'shared_v6ip': [],
              'type': ['ssh_ext', 'api_int'],
              'v6ip': '::1'
            },
            'peer': self.peer,
            'interfaces': ['lo'] + [str(net.vlan) for net in self.nets],
        }

        struct['dbnode'] = next(GLOBAL_UID_GEN)

        bonds = [net.phy for net in
                 self.nets if re.match(r'bond\d+$', net.phy)]
        for bond in bonds:
            struct[bond] = {
              'bond_miimon': '100',
              'bond_mode': 'active-backup',
              'bond_slaves': 'eth0 eth1',
            }

        roles = self.roles
        if len(roles) > 0:
            struct['role'] = self.roles

        for net in self.nets:
            struct[str(net.vlan)] = {
                'ip': net.ip_addr,
                'netmask': net.subnetmask,
                'type': net.vlan.name,
                'vlan_raw_device': net.phy
            }

        return struct


def main(excelfile, loglevel):
    """Main routine."""
    # configure default logging handler
    logging.basicConfig(level=getattr(logging, loglevel))

    # read Excel sheet
    wb = openpyxl.load_workbook(excelfile)

    ws = wb.active  # active work sheet
    msg = "Reading sheet '{}' with {} rows"
    logging.info(msg.format(ws.title, ws.max_row))

    # iterate rows to retrieve all hosts and network connections
    header = {}
    hosts = {}
    vlans = {}
    for i, row in enumerate(ws.iter_rows()):
        if i == 0:
            for j, cell in enumerate(row):
                if not cell.value or not str(cell.value).strip():
                    continue
                header[j] = str(cell.value).strip().lower()
            continue

        if not row[0].value or not row[1].value:
            continue

        net_data = {}
        net_data['ip_addr'] = row[0].value
        for j, heading in header.items():
            net_data[heading] = row[j].value

        if 'host' not in net_data or not net_data['host']:
            # skip entries without hostname
            continue

        if net_data['host'] not in hosts:
            hosts[net_data['host']] = Host(net_data['host'])

        if net_data['vlan-id'] not in vlans:
            vlans[net_data['vlan-id']] = VirtualLAN(net_data['vlan'],
                                                    net_data['vlan-id'])

        if net_data['host'].lower() == 'gateway':
            vlans[net_data['vlan-id']].gateway = hosts[net_data['host']]

        net = NetworkConnection(
            ip_addr=net_data['ip_addr'],
            subnetmask=net_data['subnetmask'],
            vlan=vlans[net_data['vlan-id']],
            phy=net_data['phy']
        )

        hosts[net_data['host']].add_net(net)

    # dump data structure YAML to retrieve a ``network.yml`` representation
    hostlist = dict((str(hostname), h.yaml()) for hostname, h in hosts.items())
    print(yaml.dump({'hosts': hostlist}, default_flow_style=False))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument('excelfile',
                        help='an Excel 2010 xlsx/xlsm file to read')
    parser.add_argument('-l', '--loglevel', default='WARN',
                        choices='CRITICAL ERROR WARN INFO DEBUG'.split(),
                        help='log level for logging module')
    args = parser.parse_args()
    main(**vars(args))
