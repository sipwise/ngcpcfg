#!/usr/bin/perl

use strict;
use warnings;

use Time::Piece;
use File::Find;

my $DEBUG = $ENV{DEBUG} || 0;
my $HNAME = $ENV{HNAME} // '';
my $TIME_FORMAT = $ENV{TIME_FORMAT} // '%F %T';
$TIME_FORMAT =~ s/^\+//;

my $TEMPLATE_POOL_BASE = $ENV{TEMPLATE_POOL_BASE};
my $CONFIG_POOL = $ENV{COFIG_POOL} // '';

my $HA_FILE = $ENV{HA_FILE};
my $HOST_FILE = $ENV{HOST_FILE};
my $PAIR_FILE = $ENV{PAIR_FILE};

sub output_prefix {
    my $t = Time::Piece->new;
    my $timestamp = $t->strftime($TIME_FORMAT);

    return "$timestamp $HNAME";
}

sub debug
{
    return unless $DEBUG;
    my $prefix = output_prefix();
    warn "$prefix: DEBUG @_\n";
}

sub warning {
    my $prefix = output_prefix();
    warn "$prefix: Warning: @_\n";
}

sub error {
    my $prefix = output_prefix();
    die "$prefix: Error: @_\n";
}

sub generate_list
{
    # Scan all directories.
    my @scan_dirs;
    foreach my $dir (split ' ', $CONFIG_POOL) {
        if (! -d $dir) {
            warning("$dir does not exist");
            next;
        }
        push @scan_dirs, "$TEMPLATE_POOL_BASE/$dir";
    }
    return if @scan_dirs == 0;

    # Scan all template files within the directories.
    my %filenames_scan;

    my $scan_regex = "(?:\.customtt)?\.tt2";
    my $scan_pro_regex;
    foreach my $part (($HA_FILE, $HOST_FILE, $PAIR_FILE)) {
        next unless defined $part;
        $scan_pro_regex .= "|$part";
    }
    $scan_regex .= "(?:$scan_pro_regex)?" if defined $scan_pro_regex;

    my $scan_tt2 = sub {
        # Ignoring foo.patchtt.tt2.* completely (it is not a tt2 template to
        # be built).
        if (m/.*\.patchtt\.tt2(?:.*)?$/) {
            debug("Ignored patchtt file '$_'");
            return;
        }

        if (s/$scan_regex$//) {
            $filenames_scan{$_}{$File::Find::name} = 1;
        }
    };

    find({
        wanted => $scan_tt2,
        follow => 1,
        follow_skip => 2,
        no_chdir => 1,
    }, @scan_dirs);

    # List of filenames, controlled by the user.
    my %filenames_set;

    # Argument(s) (file list/pattern) provided via cmdline.
    if (@ARGV == 0) {
        %filenames_set = %filenames_scan;
    } else {
        # Limit processing to requested file(s) only.
        foreach my $file (keys %filenames_scan) {
            foreach my $match (@ARGV) {
                if ($file =~ m/$match/) {
                    $filenames_set{$file} = $filenames_scan{$file};
                    last;
                }
            }
        }
    }

    # Prepare the list of variant extension in order:
    #  foo.customtt.tt2.hostname > foo.customtt.tt2.pairname >
    #  foo.customtt.tt2.spX > foo.customtt.tt2 > foo.tt2.hostname >
    #  foo.tt2.pairname > foo.tt2.spX > foo.tt2
    my @match_ext;
    # foo.custom.tt2.hostname
    push @match_ext, ".customtt.tt2$HOST_FILE" if defined $HOST_FILE;
    # foo.custom.tt2.pairname
    push @match_ext, ".customtt.tt2$PAIR_FILE" if defined $PAIR_FILE;
    # foo.customtt.tt2.sp{1,2}
    push @match_ext, ".customtt.tt2$HA_FILE" if defined $HA_FILE;
    # foo.customtt.tt2
    push @match_ext, ".customtt.tt2";
    # foo.tt2.hostname
    push @match_ext, ".tt2$HOST_FILE" if defined $HOST_FILE;
    # foo.tt2.pairname
    push @match_ext, ".tt2$PAIR_FILE" if defined $PAIR_FILE;
    # foo.tt2.sp{1,2}
    push @match_ext, ".tt2$HA_FILE" if defined $HA_FILE;
    # foo.tt2
    push @match_ext, ".tt2";

    # Final list to output.
    my %filenames;

    # Remove all filenames where a preferred filename exists.
    foreach my $file (keys %filenames_set) {
        foreach my $ext (@match_ext) {
            if (exists $filenames_set{$file}{"$file$ext"}) {
                $filenames{"$file$ext"} = 1;
                last;
            }
        }
    }

    my @filenames = sort keys %filenames;

    # Output file list, make sure we provide the file names just once, and
    # special case the ngcp-service files, as they are a second stage source
    # of data required during configuration file building, which depends at
    # the same time on the main YAML files.
    foreach my $file (@filenames) {
        print "$file\n" if $file =~ m/ngcp-service/;
    }
    foreach my $file (@filenames) {
        print "$file\n" if $file !~ m/ngcp-service/;
    }
}

error("TEMPLATE_POOL_BASE is not defined") unless $TEMPLATE_POOL_BASE;

generate_list();
