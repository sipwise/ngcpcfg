# File autogenerated by ngcpcfg

[%
hostname = ngcp.get_hostname();

PROCESS '/usr/lib/ngcp-ngcpcfg/get_ngcp_version';
ngcp_version = out;

# in SPCE there's no proper hostname, but "self", default to it
UNLESS hosts.${hostname};
   hostname = 'self';
END;

# array to track which options were already printed (to avoid reprinting when
# there are several stanzas of the interface, e.g. ipv4+ipv6 with manual common
# set-up for bonding options)
hardware_options_printed = [ ];

MACRO print_start_interface BLOCK;
   "# ${interface} ----------------------\n";
   "auto ${interface}\n";
END;

MACRO print_end_interface BLOCK;
   "# --------------------------------------------\n\n";
END;

MACRO print_bond_fields BLOCK;
   IF iface.bond_slaves;
      bslaves = iface.bond_slaves.join(" ").trim();
      "  bond-slaves ${bslaves}\n";
   END;
   IF iface.bond_mode;
      "  bond-mode ${iface.bond_mode}\n";
   END;
   IF iface.bond_miimon;
      "  bond-miimon ${iface.bond_miimon}\n";
   END;
   IF iface.bond_primary;
      "  bond-primary ${iface.bond_primary}\n";
   END;
   IF iface.bond_updelay;
      "  bond-updelay ${iface.bond_updelay}\n";
   END;
   IF iface.bond_downdelay;
      "  bond-downdelay ${iface.bond_downdelay}\n";
   END;
   IF iface.bond_xmit_hash_policy;
      "  bond-xmit_hash_policy ${iface.bond_xmit_hash_policy}\n";
   END;
END;

MACRO print_hwaddress BLOCK;
   IF iface.hwaddr and iface.hwaddr != '00:00:00:00:00:00';
      "  # skipped hwaddress since it is not supported by NGCP version ${ngcp_version}\n";
      "  #hwaddress ${iface.hwaddr}\n";
   END;
END;

MACRO print_mtu BLOCK;
   IF iface.mtu;
      IF (iface.ip or iface.v6ip or iface.dhcp == 'yes' or iface.v6dhcp == 'yes');
         "  mtu ${iface.mtu}\n";
      ELSE;
         "  pre-up ip link set dev ${iface.name} mtu ${iface.mtu}\n";
      END;
   END;
END;

MACRO print_hardware_options BLOCK;
   found='no';
   FOREACH i IN hardware_options_printed;
      IF i == iface_name;
         # "  # hw options already printed for interface ${i} == ${iface_name}\n";
         found='yes';
         LAST;
      END;
   END;

   UNLESS found == 'yes';
      hardware_options_printed.push(iface_name);
      print_hwaddress;
      print_mtu;
   END;
END;

MACRO print_address_v4 BLOCK;
   IF iface.ip;
      "  address ${iface.ip}\n";
   END;
END;

MACRO print_address_v6 BLOCK;
   IF iface.v6ip;
      "  address ${iface.v6ip}\n";
   END;
END;

MACRO print_netmask_v4 BLOCK;
   IF iface.netmask;
      "  netmask ${iface.netmask}\n";
   END;
END;

MACRO print_netmask_v6 BLOCK;
   IF iface.v6netmask;
      "  netmask ${iface.v6netmask}\n";
   END;
END;

MACRO print_gateway_v4 BLOCK;
   gateway = iface.gateway.trim();
   IF gateway;
      "  gateway ${gateway}\n";
   END;
END;

MACRO print_gateway_v6 BLOCK;
   gateway = iface.v6gateway.trim();
   IF gateway;
      "  gateway ${gateway}\n";
   END;
END;

MACRO print_dns_nameservers_v4 BLOCK;
   nservers = iface.dns_nameservers.grep('\.').join(" ").trim();
   IF nservers;
      "  dns-nameservers ${nservers}\n";
   END;
END;

MACRO print_dns_nameservers_v6 BLOCK;
   nservers = iface.dns_nameservers.grep(':').join(" ").trim();
   IF nservers;
      "  dns-nameservers ${nservers}\n";
   END;
END;

MACRO print_vlan_raw_device BLOCK;
   IF iface.vlan_raw_device;
      devs = iface.vlan_raw_device.join(" ").trim();
      "  vlan-raw-device ${devs}\n";
   END;
END;

MACRO print_pre_up_v4 BLOCK;
   IF iface.pre_up;
      FOREACH rule IN iface.pre_up;
         "  pre-up ${rule}\n";
      END;
   END;
END;

MACRO print_pre_up_v6 BLOCK;
   IF iface.v6pre_up;
      FOREACH rule IN iface.v6pre_up;
         "  pre-up ${rule}\n";
      END;
   END;
END;

MACRO print_post_up_v4 BLOCK;
   IF iface.post_up;
      FOREACH rule IN iface.post_up;
         "  post-up ${rule}\n";
      END;
   END;
END;

MACRO print_post_up_v6 BLOCK;
   IF iface.v6post_up;
      FOREACH rule IN iface.v6post_up;
         "  post-up ${rule}\n";
      END;
   END;
END;

MACRO print_pre_down_v4 BLOCK;
   IF iface.pre_down;
      FOREACH rule IN iface.pre_down;
         "  pre-down ${rule}\n";
      END;
   END;
END;

MACRO print_pre_down_v6 BLOCK;
   IF iface.v6pre_down;
      FOREACH rule IN iface.v6pre_down;
         "  pre-down ${rule}\n";
      END;
   END;
END;

MACRO print_post_down_v4 BLOCK;
   IF iface.post_down;
      FOREACH rule IN iface.post_down;
         "  post-down ${rule}\n";
      END;
   END;
END;

MACRO print_post_down_v6 BLOCK;
   IF iface.v6post_down;
      FOREACH rule IN iface.v6post_down;
         "  post-down ${rule}\n";
      END;
   END;
END;

MACRO print_up_down_v4 BLOCK;
   print_pre_up_v4;
   print_post_up_v4;
   print_pre_down_v4;
   print_post_down_v4;
END;

MACRO print_up_down_v6 BLOCK;
   print_pre_up_v6;
   print_post_up_v6;
   print_pre_down_v6;
   print_post_down_v6;
END;

MACRO print_interface BLOCK;
   iface = hosts.${hostname}.${interface};

   print_start_interface(interface=interface);

   IF interface == 'lo';
     "iface ${interface} inet loopback\n";
     "iface ${interface} inet6 loopback\n";
   ELSE;

      # print bond fields of bond interfaces separately, to happen only once
      # even when ipv4 and ipv6 are used at the same time
      IF interface.match('^bond[0-9]+$');
         "iface ${interface} inet manual\n";
         print_bond_fields(iface=iface);
         print_hardware_options(iface=iface, iface_name=interface);
      END;

      # ipv4
      IF iface.manual == 'yes';
         "iface ${interface} inet manual\n";
         print_hardware_options(iface=iface, iface_name=interface);
         print_up_down_v4(iface=iface);
      ELSIF iface.dhcp == 'yes';
         "iface ${interface} inet dhcp\n";
      ELSIF iface.ip;
         "iface ${interface} inet static\n";
         print_address_v4(iface=iface);
         print_netmask_v4(iface=iface);
         print_gateway_v4(iface=iface);
      ELSIF interface.match('^bond[0-9]+$');
         # default for some installations in Carrier when bonds don't have any
         # ip=IP/dhcp=yes configuration, and "manual" is not mandatory
         "iface ${interface} inet manual\n";
         print_hardware_options(iface=iface, iface_name=interface);
         print_up_down_v4(iface=iface);
      ELSE;
         ipv4=no;
      END;

      # ipv4-related fields
      IF iface.ip or iface.dhcp == 'yes';
         # common, they can be attached to any protocol of the interface
         print_hardware_options(iface=iface, iface_name=interface);
         print_vlan_raw_device(iface=iface);

         print_dns_nameservers_v4(iface=iface);
         print_up_down_v4(iface=iface);
      END;

      # ipv6
      IF iface.v6manual == 'yes';
         "iface ${interface} inet6 manual\n";
         print_hardware_options(iface=iface, iface_name=interface);
         print_up_down_v6(iface=iface);
      ELSIF iface.v6dhcp == 'yes';
         "iface ${interface} inet6 dhcp\n";
      ELSIF iface.v6ip;
         "iface ${interface} inet6 static\n";
         print_address_v6(iface=iface);
         print_netmask_v6(iface=iface);
         print_gateway_v6(iface=iface);
      ELSE;
         ipv6=no;
      END;

      # ipv6-related fields
      IF iface.v6ip or iface.v6dhcp == 'yes';
         # common, they can be attached to any protocol of the interface
         print_hardware_options(iface=iface, iface_name=interface);
         print_vlan_raw_device(iface=iface);

         print_dns_nameservers_v6(iface=iface);
         print_up_down_v6(iface=iface);
      END;

      # disable "Duplicate Address Detection", it creates problems with HA resource transfer
      IF iface.shared_v6ip.size;
         "  dad-attempts 0\n";
         "  pre-up echo 0 > /proc/sys/net/ipv6/conf/${interface}/accept_dad\n";
      END;

      IF ipv4 == 'no' and ipv6 == 'no';
         "# ERROR, neither IPv4 nor IPv6 present in network configuration\n";
      END;

   END;

   print_end_interface();
END;


all_interfaces = hosts.${hostname}.interfaces;

# print bond* interfaces in the beginning, needs to happen before vlan* start to
# use them, otherwise "ifup -a" does not work
FOREACH interface IN all_interfaces;
   # "# debug: host ${hostname}: processing interface ${interface}\n";

   iface = hosts.${hostname}.${interface};

   IF iface.bond_slaves;
      interfaces_in_bond = iface.bond_slaves.split(" ");
      FOREACH phys_interface IN interfaces_in_bond;

         print_start_interface(interface=phys_interface);
         "iface ${phys_interface} inet manual\n";
         "  pre-up ethtool -K ${phys_interface} sg off\n";
         print_hardware_options(iface=phys_interface, iface_name=phys_interface);
         print_up_down_v4(iface=phys_interface);
         print_end_interface();

         # remove now to not process again, but lists do not allow to remove
         # elements straight away
         all_interfaces = all_interfaces.join(" ").remove("${phys_interface}").split(" +");
      END;

      print_interface(interface=interface);
   END;
END;

# print non-bond* and non-tun* interfaces
FOREACH interface IN all_interfaces;
   # "# debug: host ${hostname}: processing interface ${interface}\n";

   iface = hosts.${hostname}.${interface};

   UNLESS iface.bond_slaves or interface.match('^tun[0-9]+$');
      print_interface(interface=interface);
   END;
END;
-%]
